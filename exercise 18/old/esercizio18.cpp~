#include<iostream>
#include<fstream>
#include<vector>
#include<iomanip>
#include<cmath>
#include<string>

using namespace std;
typedef long double ld;

//masses {m0,m1,m2}
//vars {x0,y0,z0,x1,y1,z1,x2,y2,z2,vx0,vy0,vz0,vx1,vy1,vz1,vx2,vy2,vz2}

template<typename T>
T f_vel(int i, int axis, vector<T> masses, vector<T> vars){
  vector<T> coords0 = {vars[0],vars[1],vars[2]};
  vector<T> coords1 = {vars[3],vars[4],vars[5]};
  vector<T> coords2 = {vars[6],vars[7],vars[8]};

  vector<vector<T>> planet_coords = {coords0,coords1,coords2};

  vector<T> vels0 = {vars[9],vars[10],vars[11]};
  vector<T> vels1 = {vars[12],vars[13],vars[14]};
  vector<T> vels2 = {vars[15],vars[16],vars[17]};

  vector<vector<T>> planet_vels = {vels0,vels1,vels2};

  T ret = 0;
  T den;
  for(int j=0;j<=2;j++){
    if(j==i)
      continue;
    den = powl(planet_coords[i][0] - planet_coords[j][0],2) + powl(planet_coords[i][1] - planet_coords[j][1],2) + powl(planet_coords[i][2] - planet_coords[j][2],2);
    den = powl(den,1.5);
    ret -= masses[j]*(planet_coords[i][axis] - planet_coords[j][axis])/den;
  }
  return ret;
}


template<typename T>
void integrator(ld timestep, int step_limit,vector<T> init_data,vector<T> pars,vector<T(*)(T, vector<T>, vector<T>)> funcs,string path, string method,bool test_mode,vector<T(*)(T)> solutions){
  if(step_limit>1000000  ||  init_data.size()!= funcs.size())
    return;
  vector<T> vars=init_data;
  ofstream file;
  file << setprecision(10);
  file.open(path);

  ld t=0;

  for(int i=0;i<step_limit;i++){
    if(method=="eulero"){
      vector<T> k1(init_data.size(),0);
      file << t+timestep;
      for(int j=0;j<init_data.size();j++){
	k1[j]=timestep*funcs[j](t,vars,pars);
      }
      for(int j=0;j<init_data.size();j++){
	      vars[j]+=k1[j];
	      if(test_mode){
	        //cout << "real:" << solutions[j](t+timestep) << endl;
	        //cout << " num:" << vars[j] << endl;
	        file << " " << solutions[j](t+timestep)-vars[j];
	      }else
	        file << " " << vars[j];
      }
      file << endl;
    }else if(method=="rk2"){
      vector<T> k1(init_data.size(),0),k2(init_data.size(),0),temp(init_data.size(),0);
      file << t+timestep;
      for(int j=0;j<init_data.size();j++){
	k1[j]=timestep*funcs[j](t,vars,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      temp[j]=vars[j]+k1[j]/2.;
      }

      for(int j=0;j<init_data.size();j++){
	k2[j]=timestep*funcs[j](t+timestep/2.,temp,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      vars[j]+=k2[j];
	    if(test_mode)
	      file << " " << solutions[j](t+timestep)-vars[j];
	    else
	      file << " " << vars[j];
      }
      file << endl;
    }else if(method=="rk4"){
      vector<T> k1(init_data.size(),0),k2(init_data.size(),0),k3(init_data.size(),0),k4(init_data.size(),0),temp(init_data.size(),0);
      //string line=to_string(t+timestep);
      file << t+timestep;
      for(int j=0;j<init_data.size();j++){
	k1[j]=timestep*funcs[j](t,vars,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      temp[j]=vars[j]+k1[j]/2.;
      }

      for(int j=0;j<init_data.size();j++){
	k2[j]=timestep*funcs[j](t+timestep/2.,temp,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      temp[j]=vars[j]+k2[j]/2.;
      }

      for(int j=0;j<init_data.size();j++){
	k3[j]=timestep*funcs[j](t+timestep/2.,temp,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      temp[j]=vars[j]+k3[j];
      }

      for(int j=0;j<init_data.size();j++){
	k4[j]=timestep*funcs[j](t+timestep,temp,pars);
      }

      for(int j=0;j<init_data.size();j++){
	      vars[j]+=(k1[j]+2*k2[j]+2*k3[j]+k4[j])/6.;
	    if(test_mode)
	      file << " " << solutions[j](t+timestep)-vars[j];
	      //line+=" " + to_string(solutions[j](t+timestep)-vars[j]);
	    else
	      file << " " << vars[j];
	      //line+=" " + to_string(vars[j]);
      }
      //file << line << endl;
      file<<endl;
    }else
      return;
      
    t+=timestep;
  }
  file.close();
}

int main(int argc, char** argv){
    //numero di parametri richiesti dal programma
    const int REQUIRED = 6;
    if(argc!=REQUIRED){
        cout<< "wrong arguments" << endl;
        return 1;
    }
    
    //il primo parametro passato è l'incremento temporale da usare, il secondo è il limite di step da usare
    ld timestep = stold(argv[1]);
    int step_limit = stoi(argv[2]);
    vector<ld> init = {stold(argv[3]),stold(argv[4]),stold(argv[5])};
    integrator<ld>(timestep,step_limit,init,{&fx,&fy,&fz},"eulero.dat","eulero",0,{});
    integrator<ld>(timestep,step_limit,init,{&fx,&fy,&fz},"rk2.dat","rk2",0,{});
    integrator<ld>(timestep,step_limit,init,{&fx,&fy,&fz},"rk4.dat","rk4",0,{});

    return 0;
}
